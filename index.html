<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Skeletal Path Model v2</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" />
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
    }
    .controls {
      margin-bottom: 20px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }
    svg {
      border: 1px solid #ccc;
      background: #fafcff;
    }
    .node circle {
      fill: lightblue;
      stroke: steelblue;
      stroke-width: 2px;
      cursor: pointer;
    }
    .node.selected circle {
      stroke: orange;
      stroke-width: 4px;
    }
    .node.leak circle {
      fill: #ffe0e0;
      stroke: #d22;
    }
    .node.input circle {
      stroke: green;
    }
    .node.output circle {
      stroke: purple;
    }
    .node text {
      font-size: 14px;
      pointer-events: none;
    }
    .leak-label {
      fill: #d22;
      font-size: 16px;
      font-weight: bold;
    }
    .status-box {
      margin-top: 20px;
      padding: 10px;
      background-color: #f4f4f4;
      border-radius: 5px;
      font-size: 18px;
      font-weight: bold;
      display: inline-block;
    }
  </style>
</head>
<body>
  <h2>Skeletal Path Model v2</h2>
  <div class="controls">
    <button id="add-compartment">Add Compartment</button>
    <span>Attach to: <select id="attach-to"></select></span>
    <button id="add-leak">Add Leak</button>
    <span>Leak at: <select id="leak-node"></select></span>
    <button id="move-input">Move Input</button>
    <span>Input at: <select id="input-node"></select></span>
    <button id="move-output">Move Output</button>
    <span>Output at: <select id="output-node"></select></span>
  </div>
  <div style="width: 100%; overflow-x: auto; display: flex; justify-content: center;">
    <svg id="graph" width="700" height="300"></svg>
  </div>
  <div class="status-box" id="status"></div>
  <script>
    // --- Data Model ---
    let nodes = [
      { id: 0, label: "1" },
      { id: 1, label: "2" },
    ];
    let edges = [
      { source: 0, target: 1 },
      { source: 1, target: 0 },
    ];
    let leaks = [];
    let inputNode = 0;
    let outputNode = 1;
    let nodeIdCounter = 2;

    // --- UI Elements ---
    const svg = d3.select("#graph");
    const attachToSelect = document.getElementById("attach-to");
    const leakNodeSelect = document.getElementById("leak-node");
    const inputNodeSelect = document.getElementById("input-node");
    const outputNodeSelect = document.getElementById("output-node");
    const statusDiv = document.getElementById("status");

    // --- Helper Functions ---
    function updateSelectOptions() {
      // For all selects, update options to match current nodes
      [attachToSelect, leakNodeSelect, inputNodeSelect, outputNodeSelect].forEach(sel => {
        sel.innerHTML = "";
        nodes.forEach(n => {
          const opt = document.createElement("option");
          opt.value = n.id;
          opt.textContent = n.label;
          sel.appendChild(opt);
        });
      });
      attachToSelect.value = nodes[0].id;
      leakNodeSelect.value = nodes[0].id;
      inputNodeSelect.value = inputNode;
      outputNodeSelect.value = outputNode;
    }

    function drawGraph() {
      svg.selectAll("*").remove();
      const width = +svg.attr("width");
      const height = +svg.attr("height");
      const n = nodes.length;
      // Arrange nodes in a circle
      const nodePos = {};
      nodes.forEach((node, i) => {
        const angle = (2 * Math.PI * i) / n;
        nodePos[node.id] = {
          x: width / 2 + 120 * Math.cos(angle - Math.PI / 2),
          y: height / 2 + 120 * Math.sin(angle - Math.PI / 2),
        };
      });
      // Draw edges
      svg.selectAll(".edge")
        .data(edges)
        .enter()
        .append("line")
        .attr("class", "edge")
        .attr("x1", d => nodePos[d.source].x)
        .attr("y1", d => nodePos[d.source].y)
        .attr("x2", d => nodePos[d.target].x)
        .attr("y2", d => nodePos[d.target].y)
        .attr("stroke", "#888")
        .attr("stroke-width", 2)
        .attr("marker-end", "url(#arrowhead)");
      // Arrowhead
      svg.append("defs").append("marker")
        .attr("id", "arrowhead")
        .attr("viewBox", "0 0 10 10")
        .attr("refX", 10)
        .attr("refY", 5)
        .attr("markerWidth", 6)
        .attr("markerHeight", 6)
        .attr("orient", "auto")
        .append("path")
        .attr("d", "M 0 0 L 10 5 L 0 10 z")
        .attr("fill", "#888");
      // Draw nodes
      const nodeG = svg.selectAll("g.node")
        .data(nodes)
        .enter()
        .append("g")
        .attr("class", d => {
          let c = "node";
          if (leaks.includes(d.id)) c += " leak";
          if (d.id === inputNode) c += " input";
          if (d.id === outputNode) c += " output";
          return c;
        })
        .attr("transform", d => `translate(${nodePos[d.id].x},${nodePos[d.id].y})`);
      nodeG.append("circle")
        .attr("r", 28)
        .on("click", (event, d) => {
          // Select node for future features
        });
      nodeG.append("text")
        .attr("text-anchor", "middle")
        .attr("dy", 6)
        .text(d => d.label);
      // Draw leak labels
      nodeG.filter(d => leaks.includes(d.id))
        .append("text")
        .attr("class", "leak-label")
        .attr("x", 0)
        .attr("y", 38)
        .text("leak");
      // Draw input/output labels
      nodeG.filter(d => d.id === inputNode)
        .append("text")
        .attr("x", 0)
        .attr("y", -38)
        .attr("fill", "green")
        .attr("font-size", 16)
        .attr("font-weight", "bold")
        .attr("text-anchor", "middle")
        .text("in");
      nodeG.filter(d => d.id === outputNode)
        .append("text")
        .attr("x", 0)
        .attr("y", -50)
        .attr("fill", "purple")
        .attr("font-size", 16)
        .attr("font-weight", "bold")
        .attr("text-anchor", "middle")
        .text("out");
    }

    function updateStatus() {
      // Identifiable if: shortest path from input to output <= 1 and leaks.length <= 1
      const dist = shortestPath(inputNode, outputNode);
      const ident = (dist !== null && dist <= 1 && leaks.length <= 1);
      statusDiv.textContent = ident ? "Identifiable" : "Unidentifiable";
      statusDiv.style.color = ident ? "green" : "red";
    }

    function shortestPath(start, end) {
      // BFS for shortest path
      if (start === end) return 0;
      const visited = new Set();
      let queue = [{ node: start, dist: 0 }];
      while (queue.length > 0) {
        const { node, dist } = queue.shift();
        if (node === end) return dist;
        visited.add(node);
        edges.forEach(e => {
          if (e.source === node && !visited.has(e.target)) {
            queue.push({ node: e.target, dist: dist + 1 });
          }
        });
      }
      return null; // not reachable
    }

    // --- Event Handlers ---
    document.getElementById("add-compartment").onclick = () => {
      const attachTo = +attachToSelect.value;
      const newId = nodeIdCounter++;
      nodes.push({ id: newId, label: (nodes.length + 1).toString() });
      // Add both directed edges
      edges.push({ source: newId, target: attachTo });
      edges.push({ source: attachTo, target: newId });
      updateSelectOptions();
      drawGraph();
      updateStatus();
    };
    document.getElementById("add-leak").onclick = () => {
      const leakAt = +leakNodeSelect.value;
      if (!leaks.includes(leakAt)) leaks.push(leakAt);
      drawGraph();
      updateStatus();
    };
    document.getElementById("move-input").onclick = () => {
      inputNode = +inputNodeSelect.value;
      drawGraph();
      updateStatus();
    };
    document.getElementById("move-output").onclick = () => {
      outputNode = +outputNodeSelect.value;
      drawGraph();
      updateStatus();
    };

    // --- Initial Render ---
    updateSelectOptions();
    drawGraph();
    updateStatus();
  </script>
</body>
</html> 
